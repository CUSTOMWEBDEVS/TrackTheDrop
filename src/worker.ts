/// <reference lib="webworker" />
import type { FrameMsg, ResultMsg } from './workerTypes';
const ctxCache=new Map<number,OffscreenCanvasRenderingContext2D>();
function getCtx(w:number,h:number){const key=(w<<16)^h;let ctx=ctxCache.get(key);if(!ctx){const c=new OffscreenCanvas(w,h);ctx=c.getContext('2d',{willReadFrequently:true})!;ctxCache.set(key,ctx);}else{const c=ctx.canvas as OffscreenCanvas;if(c.width!==w||c.height!==h){c.width=w;c.height=h;}}return ctx!;}
function toHSV(r:number,g:number,b:number){const rn=r/255,gn=g/255,bn=b/255;const max=Math.max(rn,gn,bn),min=Math.min(rn,gn,bn);const d=max-min;let h=0;if(d!==0){if(max===rn)h=((gn-bn)/d+(gn<bn?6:0));else if(max===gn)h=((bn-rn)/d+2);else h=((rn-gn)/d+4);h/=6;}const s=max===0?0:d/max;const v=max;return{h,s,v};}
function morph(binary:Uint8ClampedArray,w:number,h:number,r:number){if(r<=0)return;const tmp=new Uint8ClampedArray(binary.length);for(let iter=0;iter<r;iter++){for(let y=1;y<h-1;y++){for(let x=1;x<w-1;x++){let keep=255;for(let j=-1;j<=1;j++)for(let i=-1;i<=1;i++){if(binary[((y+j)*w+(x+i))<<2]===0){keep=0;break;}}const off=(y*w+x)<<2;tmp[off]=tmp[off+1]=tmp[off+2]=keep;tmp[off+3]=255;}}binary.set(tmp);for(let y=1;y<h-1;y++){for(let x=1;x<w-1;x++){let on=0;for(let j=-1;j<=1;j++)for(let i=-1;i<=1;i++){if(binary[((y+j)*w+(x+i))<<2]!==0){on=255;break;}}const off=(y*w+x)<<2;tmp[off]=tmp[off+1]=tmp[off+2]=on;tmp[off+3]=255;}}binary.set(tmp);}}
self.onmessage=async (e:MessageEvent<FrameMsg>)=>{const {bitmap,width,height,params}=e.data;const {thr,sens,morph:mr,debugHeat,showMask}=params;const ctx=getCtx(width,height);ctx.drawImage(bitmap,0,0,width,height);bitmap.close();const img=ctx.getImageData(0,0,width,height);const data=img.data;const heat=new Float32Array(width*height);let minH=1e9,maxH=-1e9;for(let p=0,i=0;p<data.length;p+=4,i++){const r=data[p],g=data[p+1],b=data[p+2];const sum=r+g+b+1e-6;const normR=r/sum;const rgDiff=Math.max(0,(r-g)/255);const {s,v}=toHSV(r,g,b);const vGate=Math.max(0.0,v-(0.25*(1-sens)));let hval=0.62*normR+0.25*rgDiff+0.13*s;hval*=vGate;heat[i]=hval;if(hval<minH)minH=hval;if(hval>maxH)maxH=hval;}const scale=1/Math.max(1e-6,maxH-minH);const mask=ctx.createImageData(width,height);for(let i=0,p=0;i<heat.length;i++,p+=4){const n=(heat[i]-minH)*scale;const on=n>=thr?255:0;mask.data[p]=mask.data[p+1]=mask.data[p+2]=on;mask.data[p+3]=255;heat[i]=n;}if(mr>0)morph(mask.data,width,height,mr);const out=ctx.getImageData(0,0,width,height);const od=out.data;const md=mask.data;if(debugHeat){for(let i=0,p=0;i<heat.length;i++,p+=4){const n=heat[i];od[p]=Math.min(255,n*255);od[p+1]=0;od[p+2]=Math.min(255,(1-n)*255);od[p+3]=255;}}else if(showMask){for(let p=0;p<od.length;p+=4){if(md[p]){od[p]=Math.max(od[p],220);od[p+1]=Math.min(od[p+1],30);od[p+2]=Math.min(od[p+2],30);}else{od[p]=(od[p]*0.8)|0;od[p+1]=(od[p+1]*0.85)|0;od[p+2]=(od[p+2]*0.9)|0;}}}ctx.putImageData(out,0,0);const resultBitmap=await (ctx.canvas as OffscreenCanvas).convertToBlob({type:'image/png'}).then(b=>createImageBitmap(b));const msg:ResultMsg={type:'result',bitmap:resultBitmap};self.postMessage(msg,[resultBitmap]);};